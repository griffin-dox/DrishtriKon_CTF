    
    # Relationships
    users = db.relationship('UserBadge', back_populates='badge', lazy=True)

# User-Badge Association Model
class UserBadge(db.Model):
    __tablename__ = 'user_badges'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    badge_id = db.Column(db.Integer, db.ForeignKey('badges.id'), nullable=False)
    awarded_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    user = db.relationship('User', back_populates='badges')
    badge = db.relationship('Badge', back_populates='users')

# Competition-Challenge Association Model
class CompetitionChallenge(db.Model):
    __tablename__ = 'competition_challenges'
    
    id = db.Column(db.Integer, primary_key=True)
    competition_id = db.Column(db.Integer, db.ForeignKey('competitions.id'), nullable=False)
    challenge_id = db.Column(db.Integer, db.ForeignKey('challenges.id'), nullable=False)
    release_time = db.Column(db.DateTime, nullable=True)
    is_active = db.Column(db.Boolean, default=True)
    
    # Relationships
    competition = db.relationship('Competition', back_populates='challenges')
    challenge = db.relationship('Challenge', back_populates='competitions')

# Competition-Host Association Model
class CompetitionHost(db.Model):
    __tablename__ = 'competition_hosts'
    
    id = db.Column(db.Integer, primary_key=True)
    competition_id = db.Column(db.Integer, db.ForeignKey('competitions.id'), nullable=False)
    host_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    assigned_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    competition = db.relationship('Competition', backref=db.backref('additional_hosts', lazy=True))
    host = db.relationship('User', backref=db.backref('assigned_competitions', lazy=True))

# User-Competition Association Model
class UserCompetition(db.Model):
    __tablename__ = 'user_competitions'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    competition_id = db.Column(db.Integer, db.ForeignKey('competitions.id'), nullable=False)
    score = db.Column(db.Integer, default=0)
    joined_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    user = db.relationship('User', back_populates='competitions')
    competition = db.relationship('Competition', back_populates='participants')


# Team Status Enum
class TeamStatus(enum.Enum):
    PENDING = "pending"
    ACTIVE = "active"
    INACTIVE = "inactive"
    
class TeamRole(enum.Enum):
    CAPTAIN = "captain"
    MEMBER = "member"
    
# Team Model
class Team(db.Model):
    __tablename__ = 'teams'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True, nullable=False)
    description = db.Column(db.Text, nullable=True)
    avatar = db.Column(db.String(255), nullable=True)
    status = db.Column(db.String(20), default='active', nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    members = db.relationship('TeamMember', back_populates='team', lazy=True)
    competitions = db.relationship('TeamCompetition', back_populates='team', lazy=True)
    
    # Get the team captain
    def get_captain(self):
        captain = TeamMember.query.filter_by(
            team_id=self.id, 
            role='captain'
        ).first()
        return captain
    
    # Get all team members including the captain
    def get_all_members(self):
        return TeamMember.query.filter_by(team_id=self.id).all()
    
    # Count total members
    def member_count(self):
        return TeamMember.query.filter_by(team_id=self.id).count()
    
    # Check if the team is full (maximum 5 members)
    def is_full(self):
        return self.member_count() >= 5
    
    # Check if the team has minimum required members (2)
    def has_minimum_members(self):
        return self.member_count() >= 2
        
# Team Member Model
class TeamMember(db.Model):
    __tablename__ = 'team_members'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    team_id = db.Column(db.Integer, db.ForeignKey('teams.id'), nullable=False)
    role = db.Column(db.String(20), default='member', nullable=False)
    joined_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships with proper overlaps
    user = db.relationship('User', overlaps="team_memberships,user_account")
    team = db.relationship('Team', back_populates='members')
    
    # Ensure uniqueness of user-team combination
    __table_args__ = (
        db.UniqueConstraint('user_id', 'team_id', name='_user_team_uc'),
    )
    
# Team Competition Model - tracks team participation in competitions
class TeamCompetition(db.Model):
    __tablename__ = 'team_competitions'
    
    id = db.Column(db.Integer, primary_key=True)
    team_id = db.Column(db.Integer, db.ForeignKey('teams.id'), nullable=False)
    competition_id = db.Column(db.Integer, db.ForeignKey('competitions.id'), nullable=False)
    score = db.Column(db.Integer, default=0)
    joined_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships
    team = db.relationship('Team', back_populates='competitions')
    competition = db.relationship('Competition')
    
    # Ensure uniqueness of team-competition combination
    __table_args__ = (
        db.UniqueConstraint('team_id', 'competition_id', name='_team_competition_uc'),
    )

class AdLocation(enum.Enum):
    LEFT_SIDEBAR = "left_sidebar"
    RIGHT_SIDEBAR = "right_sidebar"
    HORIZONTAL_TOP = "horizontal_top"
    HORIZONTAL_BOTTOM = "horizontal_bottom"
    HOME_HORIZONTAL = "home_horizontal"


class AdConfiguration(db.Model):
    __tablename__ = 'ad_configuration'
    
    id = db.Column(db.Integer, primary_key=True)
    use_google_ads = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)


class AdImage(db.Model):
    __tablename__ = 'ad_images'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    image_path = db.Column(db.String(512), nullable=False)
    link_url = db.Column(db.String(512), nullable=True)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    placements = db.relationship('AdPlacement', back_populates='ad_image', lazy=True)
    

class AdPlacement(db.Model):
    __tablename__ = 'ad_placements'
    
    id = db.Column(db.Integer, primary_key=True)
    ad_image_id = db.Column(db.Integer, db.ForeignKey('ad_images.id'), nullable=False)
    location = db.Column(db.Enum(AdLocation), nullable=False)
    is_exclusive = db.Column(db.Boolean, default=False)  # If True, only this ad shows in this location
    start_date = db.Column(db.DateTime, nullable=True)
    end_date = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    ad_image = db.relationship('AdImage', back_populates='placements')
